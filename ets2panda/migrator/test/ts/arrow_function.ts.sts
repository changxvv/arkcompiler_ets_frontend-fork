/*
 * Copyright (c) 2022-2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */  
 
type MyFunction = (x : Double, y : Boolean): String ;
interface I {
    m(): Double ;
}

function createLambda(): (): Double  {
    return (): Double => 10;
}
function filter(array : Double[], predicate : (x : Double): Boolean ): Double[] {
    let newArray : Double[] = [];
    for (let element of array){
        if (predicate(element)) newArray.push(element);
    }
    return newArray;
}
function main(): void {
    let empty = (): void => {
    }
;
    empty();
    let double : (x : Double): Double  = (x : Double): Double => x * x;
    console.log(double(10));
    let foo = createLambda();
    let a : Double = foo();
    let b : Double = createLambda()();
    let bar : MyFunction = (x : Double, y : Boolean): String => "value";
    console.log(bar(10, true));
    let restParam = (x : Double, y : Double, ... rest: Double[] ): void => {
        for (let z of rest){
            console.log(x + y + z);
        }
    }
;
    restParam(1, 2);
    restParam(1, 2, 3);
    restParam(1, 2, 3, 4);
    restParam(1, 2, 3, 4, 5);
    ((): String => "foobar")();
    let factorial = (n : Double): Double => {
        if (n === 1) return 1;
        else return n * factorial(n - 1);
    }
;
    console.log(factorial(5));
    let array = [1, 2, 3, 4, 5, 6];
    let square = array.map((e : Double): Double => e * e);
    let even = filter(array, (x : Double): Boolean => x % 2 === 0);
    let generic = __untranslated_expression( /* <T, E> (t: T, e: E) => t */);
    generic(100, "apple");
    let baz : String = generic< /* string, number */>("orange", 25);
    let generic2 = __untranslated_expression( /* <W extends I> (w: W): void => {         w.m();     } */);
    generic2(__invalid_expression( /* { m() { return 0; } } */));
}
