/*
 * Copyright (c) 2022-2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ohos.migrator.test.java;

import * from "std/math/math";
// Enum implements an interface.
// Constants with class body (anonymous class declaration).
interface IOperation {
    apply(a : int, b : int): int ;
}

open class ArithmeticOperation extends Enum<ArithmeticOperation> implements IOperation  {
    public static readonly PLUS : ArithmeticOperation = new ArithmeticOperation("PLUS", 0) {
        public override apply(a : int, b : int): int {
            return a + b;
        }
    };
    public static readonly MINUS : ArithmeticOperation = new ArithmeticOperation("MINUS", 1) {
        public override apply(a : int, b : int): int {
            return a - b;
        }
    };
    public static readonly MULTIPLY : ArithmeticOperation = new ArithmeticOperation("MULTIPLY", 2) {
        public override apply(a : int, b : int): int {
            return a * b;
        }
    };
    public static readonly DIVIDE : ArithmeticOperation = new ArithmeticOperation("DIVIDE", 3) {
        public override apply(a : int, b : int): int {
            return a / b;
        }
    };
// tests enum instance initializer translation
// super(name, ordinal) call should be inserted
// into resulting ctor!
    private foo : String ;
    public static values(): ArithmeticOperation[] {
        return [PLUS, MINUS, MULTIPLY, DIVIDE];
    }
    public static valueOf(name : String): ArithmeticOperation {
        for (let value : ArithmeticOperation of values()){
            if (name == value.toString()) return value;
        }
        return null;
    }
    private constructor(name : String, ordinal : int) {
        super(name, ordinal);
        foo = "bar";
    }

}

// Enum declaration with type members (ctor, methods, etc).
// Constants are initialized through constructor.
class Planet extends Enum<Planet>  {
    public static readonly MERCURY : Planet = new Planet("MERCURY", 0, 3.303e+23, 2.4397e6);
    public static readonly VENUS : Planet = new Planet("VENUS", 1, 4.869e+24, 6.0518e6);
    public static readonly EARTH : Planet = new Planet("EARTH", 2, 5.976e+24, 6.37814e6);
    public static readonly MARS : Planet = new Planet("MARS", 3, 6.421e+23, 3.3972e6);
    public static readonly JUPITER : Planet = new Planet("JUPITER", 4, 1.9e+27, 7.1492e7, PlanetType.GAS);
    public static readonly SATURN : Planet = new Planet("SATURN", 5, 5.688e+26, 6.0268e7, PlanetType.GAS);
    public static readonly URANUS : Planet = new Planet("URANUS", 6, 8.686e+25, 2.5559e7, PlanetType.ICE);
    public static readonly NEPTUNE : Planet = new Planet("NEPTUNE", 7, 1.024e+26, 2.4746e7, PlanetType.ICE);
    class PlanetType extends Enum<PlanetType>  {
        public static readonly ROCK : PlanetType = new PlanetType("ROCK", 0);
        public static readonly GAS : PlanetType = new PlanetType("GAS", 1);
        public static readonly ICE : PlanetType = new PlanetType("ICE", 2);
        public static values(): PlanetType[] {
            return [ROCK, GAS, ICE];
        }
        public static valueOf(name : String): PlanetType {
            for (let value : PlanetType of values()){
                if (name == value.toString()) return value;
            }
            return null;
        }
        private constructor(name : String, ordinal : int) {
            super(name, ordinal);
        }

    }

    private mass : double ; // in kilograms
    private radius : double ; // in meters
    private type : PlanetType ;
    constructor(name : String, ordinal : int, mass : double, radius : double, type : PlanetType) {
        super(name, ordinal);
        this.mass = mass;
        this.radius = radius;
        this.type = type;
    }

    constructor(name : String, ordinal : int, mass : double, radius : double) {
        // No super(name, ordinal) call in translation here!
this(name, ordinal, mass, radius, PlanetType.ROCK);
    }

// Checks addition of name and ordinal parameters
// to explcitly-defined parameter-less enum ctor.
    private constructor(name : String, ordinal : int) {
        super(name, ordinal);
        mass = 0.;
        radius = 0.;
        type = PlanetType.ROCK;
    }

// Checks addition of name and ordinal arguments
// to explicit parameter-less ctor call
    private constructor(name : String, ordinal : int, mass : double) {
        this(name, ordinal);
    }

// universal gravitational constant  (m3 kg-1 s-2)
    public static readonly G : double = 6.67300E-11;
    open surfaceGravity(): double {
        return G * mass / (radius * radius);
    }
    open surfaceWeight(otherMass : double): double {
        return otherMass * surfaceGravity();
    }
    public static values(): Planet[] {
        return [MERCURY, VENUS, EARTH, MARS, JUPITER, SATURN, URANUS, NEPTUNE];
    }
    public static valueOf(name : String): Planet {
        for (let value : Planet of values()){
            if (name == value.toString()) return value;
        }
        return null;
    }
}

