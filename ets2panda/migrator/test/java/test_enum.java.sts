/*
 * Copyright (c) 2022-2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ohos.migrator.test.java;

import * from "std/math/math";
// Empty enum
export class test_enum extends Enum<test_enum>  {
    public static values(): test_enum[] {
        return [];
    }
    public static valueOf(name : String): test_enum {
        for (let value : test_enum of values()){
            if (name == value.toString()) return value;
        }
        return null;
    }
    private constructor(name : String, ordinal : int) {
        super(name, ordinal);
    }

}
class Planet extends Enum<Planet>  {
    public static readonly MERCURY : Planet = new Planet("MERCURY", 0);
    public static readonly VENUS : Planet = new Planet("VENUS", 1);
    public static readonly EARTH : Planet = new Planet("EARTH", 2);
    public static readonly MARS : Planet = new Planet("MARS", 3);
    public static readonly JUPITER : Planet = new Planet("JUPITER", 4);
    public static readonly SATURN : Planet = new Planet("SATURN", 5);
    public static readonly URANUS : Planet = new Planet("URANUS", 6);
    public static readonly NEPTUNE : Planet = new Planet("NEPTUNE", 7);

    public static values(): Planet[] {
        return [MERCURY, VENUS, EARTH, MARS, JUPITER, SATURN, URANUS, NEPTUNE];
    }
    public static valueOf(name : String): Planet {
        for (let value : Planet of values()){
            if (name == value.toString()) return value;
        }
        return null;
    }
    private constructor(name : String, ordinal : int) {
        super(name, ordinal);
    }
}
// Nested enums with different modifiers
open class NestedEnums  {
    private class Colors extends Enum<Colors>  {
        public static readonly RED : Colors = new Colors("RED", 0);
        public static readonly GREEN : Colors = new Colors("GREEN", 1);
        public static readonly BLUE : Colors = new Colors("BLUE", 2);

        public static values(): Colors[] {
            return [RED, GREEN, BLUE];
        }
        public static valueOf(name : String): Colors {
            for (let value : Colors of values()){
                if (name == value.toString()) return value;
            }
            return null;
        }
        private constructor(name : String, ordinal : int) {
            super(name, ordinal);
        }
    }
    protected class Size extends Enum<Size>  {
        public static readonly SMALL : Size = new Size("SMALL", 0);
        public static readonly MEDIUM : Size = new Size("MEDIUM", 1);
        public static readonly LARGE : Size = new Size("LARGE", 2);

        public static values(): Size[] {
            return [SMALL, MEDIUM, LARGE];
        }
        public static valueOf(name : String): Size {
            for (let value : Size of values()){
                if (name == value.toString()) return value;
            }
            return null;
        }
        private constructor(name : String, ordinal : int) {
            super(name, ordinal);
        }
    }
    public class Direction extends Enum<Direction>  {
        public static readonly NORTH : Direction = new Direction("NORTH", 0);
        public static readonly EAST : Direction = new Direction("EAST", 1);
        public static readonly SOUTH : Direction = new Direction("SOUTH", 2);
        public static readonly WEST : Direction = new Direction("WEST", 3);

        public static values(): Direction[] {
            return [NORTH, EAST, SOUTH, WEST];
        }
        public static valueOf(name : String): Direction {
            for (let value : Direction of values()){
                if (name == value.toString()) return value;
            }
            return null;
        }
        private constructor(name : String, ordinal : int) {
            super(name, ordinal);
        }
    }
    class Operator extends Enum<Operator>  {
        public static readonly PLUS : Operator = new Operator("PLUS", 0);
        public static readonly MINUS : Operator = new Operator("MINUS", 1);
        public static readonly MULTIPLY : Operator = new Operator("MULTIPLY", 2);
        public static readonly DIVIDE : Operator = new Operator("DIVIDE", 3);

        public static values(): Operator[] {
            return [PLUS, MINUS, MULTIPLY, DIVIDE];
        }
        public static valueOf(name : String): Operator {
            for (let value : Operator of values()){
                if (name == value.toString()) return value;
            }
            return null;
        }
        private constructor(name : String, ordinal : int) {
            super(name, ordinal);
        }
    }
}

