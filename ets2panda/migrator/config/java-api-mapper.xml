<?xml version="1.0" encoding="UTF-8"?>

<!--
 * Copyright (c) 2022-2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->

<JavaApiMappingRules>
    <ImportRules>
        <!--
            For some items from 'java.lang' package its equivalents in ArkTS located in NOT implicitly imported packages.
            To make such items available for usage corresponding imports have to be added to the resulting code.
            In the first iteration add the imports always without attempt to figure out whether any item of the packages is
            really used in the code or not.

            ImportDeclarationRules without 'javaImport' attribute defines such mandatory imports.
            'acction="add"' is not required and present only for better human readability of the rules.
        -->
        <ImportDeclarationRule action="add"> <ImportDeclaration arktsItem="*" arktsFrom="std/math/math"/> </ImportDeclarationRule>

        <ImportDeclarationRule javaImport="java.lang.*" action="remove"/> <!-- There is no need to do such import in ArkTS. -->
        <ImportDeclarationRule javaImport="java.lang.Comparable" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.Boolean" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.Byte" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.Character" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.Class" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.Double" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.Float" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.Integer" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.Long" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.Math" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.Number" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.Object" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.Runtime" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.Short" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.String" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.StringBuilder" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.System" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.ArithmeticException" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.ArrayIndexOutOfBoundsException" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.Exception" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.NullPointerException" action="remove"/>
        <ImportDeclarationRule javaImport="java.lang.reflect.Type" action="remove"/>

        <ImportDeclarationRule javaImport="java.util.Arrays" action="remove"/> <!-- It is moved to std.core.Array which is available without import. -->

        <ImportDeclarationRule javaImport="java.util.Map" action="replace"> <ImportDeclaration arktsItem="Map" arktsFrom="std/containers"/> </ImportDeclarationRule>
        <ImportDeclarationRule javaImport="java.util.Set" action="replace"> <ImportDeclaration arktsItem="Set" arktsFrom="std/containers"/> </ImportDeclarationRule>
        <ImportDeclarationRule javaImport="java.util.Data" action="replace"> <ImportDeclaration arktsItem="Date" arktsFrom="std/time"/> </ImportDeclarationRule>
        <ImportDeclarationRule javaImport="java.util.*" action="replace">
            <!-- The list below is not complete. It reflects current state of the standard library. -->
            <ImportDeclaration arktsItem="*" arktsFrom="std/containers"/>
            <ImportDeclaration arktsItem="*" arktsFrom="std/time"/> <!-- java.util.Date ==> std.time.Data -->
        </ImportDeclarationRule>
    </ImportRules>

    <CallRules>
        <CallRules.java.lang.Math>
            <CallExpressionRule javaType="java.lang.Math" javaMethodName="abs" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="acos" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="asin" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="atan" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="atan2" javaMethodArgs="double,double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="cbrt" javaMethodArgs="double">
                <!-- rename java.lang.Math.cbrt() ==> std.std.math.math.cuberoot() -->
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
                <ArktsMethodName value="cuberoot"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="cos" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="cosh" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="exp" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="expm1" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="floor" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="hypot" javaMethodArgs="double,double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="log" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="log10" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="log1p" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="max" javaMethodArgs="double,double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="max" javaMethodArgs="int,int">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="min" javaMethodArgs="double,double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="min" javaMethodArgs="int,int">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="round" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="sin" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="sinh" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="sqrt" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="tan" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="tanh" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="pow" javaMethodArgs="double,double">
                <!-- rename java.lang.Math.pow() ==> std.std.math.math.power() -->
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
                <ArktsMethodName value="power"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="scalb" javaMethodArgs="double,int">
                <!-- rename java.lang.Math.scalb() ==> std.std.math.math.scalbn() -->
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
                <ArktsMethodName value="scalbn"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="scalb" javaMethodArgs="float,int">
                <!-- rename java.lang.Math.scalb() ==> std.std.math.math.scalbn() -->
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
                <ArktsMethodName value="scalbn"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="signum" javaMethodArgs="double">
                <!-- rename java.lang.Math.signum() ==> std.std.math.math.sign() -->
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
                <ArktsMethodName value="sign"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="signum" javaMethodArgs="float">
                <!-- rename java.lang.Math.signum() ==> std.std.math.math.sign() -->
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
                <ArktsMethodName value="sign"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="getExponent" javaMethodArgs="float">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
                <!-- This rule specifies the type argument for the resulting generic method. -->
                <ArktsMethodTypeArgs>
                    <TypeArguments>
                        <TypeReference arktsTypeName="Float"/>
                    </TypeArguments>
                </ArktsMethodTypeArgs>
                <!-- <Arguments> element is needed only to doe the type cast. And it needed as the convertor flat literals
                converts to double (as ArkTS doesn't have any prefix for float literal types). -->
                <Arguments>
                    <CastExpression index="0"> <!-- The original argument index to be cast. -->
                        <PrimaryType> <!-- The type to which to do the cast. -->
                            <PredefinedType name="float"/>
                        </PrimaryType>
                    </CastExpression>
                </Arguments>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Math" javaMethodName="getExponent" javaMethodArgs="double">
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
                <!-- This rule specifies the type argument for the resulting generic method. -->
                <ArktsMethodTypeArgs>
                    <TypeArguments>
                        <TypeReference arktsTypeName="Double"/>
                    </TypeArguments>
                </ArktsMethodTypeArgs>
            </CallExpressionRule>
        </CallRules.java.lang.Math>

        <CallRules.java.util.Arrays>
            <CallExpressionRule javaType="java.util.Arrays" javaMethodName="binarySearch" javaMethodArgs="int[],int,int,int">
                <!--
                    static int binarySearch(int[] a, int fromIndex, int toIndex, int key)
                    ==>
                    function indexOf(arr: int[], key: int, startIndex: int, endIndex: int): int
                -->
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
                <ArktsMethodName value="indexOf"/>
                <Arguments>
                    <!-- Reorder the arguments. -->
                    <SrcArgument index="0"/>
                    <SrcArgument index="3"/>
                    <SrcArgument index="1"/>
                    <SrcArgument index="2"/>
                </Arguments>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.util.Arrays" javaMethodName="binarySearch" javaMethodArgs="int[],int">
                <!--
                    static int 	binarySearch(int[] a, int key)
                    ==>
                    function indexOf(arr: int[], key: int): int
                -->
                <ArktsMethodName value="indexOf"/>
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.util.Arrays" javaMethodName="fill" javaMethodArgs="int[],int,int,int">
                <!--
                    static void fill(byte[] a, int fromIndex, int toIndex, byte val)
                    ==>
                    function fill(arr: int[], value: int, startIndex: int, endIndex: int): void
                -->
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
                <!-- The method name is the same ==> there is no ArktsMethodName element here. -->
                <Arguments>
                    <!-- Reorder the arguments. -->
                    <SrcArgument index="0"/>
                    <SrcArgument index="3"/>
                    <SrcArgument index="1"/>
                    <SrcArgument index="2"/>
                </Arguments>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.util.Arrays" javaMethodName="copyOfRange" javaMethodArgs="int[],int,int">
                <!--
                    static int[] copyOfRange(int[] original, int from, int to)
                    ==>
                    function copyOf(arr: int[], startIndex: int, endIndex: int): int[]
                -->
                <ArktsMethodName value="copyOf"/>
                <ArktsTypeName value=""/> <!-- The empty value means the function in ArkTS is a global one. -->
            </CallExpressionRule>
        </CallRules.java.util.Arrays>

        <CallRules.java.lang.Boolean>
            <CallExpressionRule javaType="java.lang.Boolean" javaMethodName="booleanValue">
                <!--
                    boolean booleanValue()
                    ==>
                    public unboxed(): boolean
                -->
                <ArktsMethodName value="unboxed"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Boolean" javaMethodName="compare" javaMethodArgs="boolean,boolean">
                <!--
                    static int compare(boolean x, boolean y)
                    ==>
                    new Boolean(x).compareTo(new Boolean(y))
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Boolean(x) -->
                        <TypeReference arktsTypeName="Boolean"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>

                <ArktsMethodName value="compareTo"/>
                <Arguments>
                    <NewClassInstanceExpression> <!-- new Boolean(y) -->
                        <TypeReference arktsTypeName="Boolean"/>
                        <Arguments>
                            <SrcArgument index="1"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </Arguments>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Boolean" javaMethodName="hashCode" javaMethodArgs="boolean">
                <!--
                    static int hashCode(boolean x)
                    ==>
                    new Boolean(x).hashCode()
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Boolean(x) -->
                        <TypeReference arktsTypeName="Boolean"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>

                <Arguments/> <!-- Denotes an empty list of arguments. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Boolean" javaMethodName="toString" javaMethodArgs="boolean">
                <!--
                    static int toString(boolean x)
                    ==>
                    new Boolean(x).toString()
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Boolean(x) -->
                        <TypeReference arktsTypeName="Boolean"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>

                <Arguments/> <!-- Denotes an empty list of arguments. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Boolean" javaMethodName="logicalAnd" javaMethodArgs="boolean,boolean">
              <!--
                  static int logicalAnd(boolean x, boolean y)
                  ==>
                  new Boolean(x).and(new Boolean(y))
              -->
                <ArktsObject>
                    <NewClassInstanceExpression>
                        <TypeReference arktsTypeName="Boolean" />
                        <Arguments>
                            <SrcArgument index="0" />
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>
                <ArktsMethodName value="and" />
                <Arguments>
                    <NewClassInstanceExpression>
                        <TypeReference arktsTypeName="Boolean" />
                        <Arguments>
                            <SrcArgument index="1" />
                        </Arguments>
                    </NewClassInstanceExpression>
                </Arguments>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Boolean" javaMethodName="logicalOr" javaMethodArgs="boolean,boolean">
              <!--
                  static int logicalOr(boolean x, boolean y)
                  ==>
                  new Boolean(x).or(new Boolean(y))
              -->
                <ArktsObject>
                    <NewClassInstanceExpression>
                        <TypeReference arktsTypeName="Boolean" />
                        <Arguments>
                            <SrcArgument index="0" />
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>
                <ArktsMethodName value="or" />
                <Arguments>
                    <NewClassInstanceExpression>
                        <TypeReference arktsTypeName="Boolean" />
                        <Arguments>
                            <SrcArgument index="1" />
                        </Arguments>
                    </NewClassInstanceExpression>
                </Arguments>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Boolean" javaMethodName="logicalXor" javaMethodArgs="boolean,boolean">
              <!--
                  static int logicalXor(boolean x, boolean y)
                  ==>
                  new Boolean(x).xor(new Boolean(y))
              -->
                <ArktsObject>
                    <NewClassInstanceExpression>
                        <TypeReference arktsTypeName="Boolean" />
                        <Arguments>
                            <SrcArgument index="0" />
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>
                <ArktsMethodName value="xor" />
                <Arguments>
                    <NewClassInstanceExpression>
                        <TypeReference arktsTypeName="Boolean" />
                        <Arguments>
                            <SrcArgument index="1" />
                        </Arguments>
                    </NewClassInstanceExpression>
                </Arguments>
            </CallExpressionRule>
        </CallRules.java.lang.Boolean>

        <CallRules.java.lang.Byte>
            <CallExpressionRule javaType="java.lang.Byte" javaMethodName="toString" javaMethodArgs="byte">
                <!--
                    static String toString(byte b)
                    ==>
                    new Byte(b).toString()
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Byte(b) -->
                        <TypeReference arktsTypeName="Byte"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>

                <Arguments/> <!-- Denotes an empty list of arguments. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Byte" javaMethodName="hashCode" javaMethodArgs="byte">
                <!--
                    static int hashCode(byte b)
                    ==>
                    new Byte(b).hashCode()
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Byte(b) -->
                        <TypeReference arktsTypeName="Byte"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>

                <Arguments/> <!-- Denotes an empty list of arguments. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Byte" javaMethodName="compare" javaMethodArgs="byte,byte">
                <!--
                    static int compare(byte b1, byte b2)
                    ==>
                    new Byte(b1).compareTo(new Byte(b2))
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Byte(b1) -->
                        <TypeReference arktsTypeName="Byte"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>

                <ArktsMethodName value="compareTo"/>
                <Arguments>
                    <NewClassInstanceExpression> <!-- new Byte(b2) -->
                        <TypeReference arktsTypeName="Byte"/>
                        <Arguments>
                            <SrcArgument index="1"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </Arguments>
            </CallExpressionRule>
        </CallRules.java.lang.Byte>

        <CallRules.java.lang.Character>
            <CallExpressionRule javaType="java.lang.Character" javaMethodName="compare" javaMethodArgs="char,char">
                <!--
                    static int compare(char c1, char c2)
                    ==>
                    new Char(c1).compareTo(new Char(c2))
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Char(c1) -->
                        <TypeReference arktsTypeName="Char"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>

                <ArktsMethodName value="compareTo"/>
                <Arguments>
                    <NewClassInstanceExpression> <!-- new Double(c2) -->
                        <TypeReference arktsTypeName="Char"/>
                        <Arguments>
                            <SrcArgument index="1"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </Arguments>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Character" javaMethodName="hashCode" javaMethodArgs="char">
                <!--
                    static int Character.hashCode(char value)
                    ==>
                    static Char.hashCode(value: char): int
                -->
                <ArktsTypeName value="Char"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Character" javaMethodName="highSurrogate" javaMethodArgs="int">
                <!--
                    static char Character.highSurrogate(int codePoint)
                    ==>
                    static Char.getHighSurrogate(codePoint: int): char
                -->
                <ArktsTypeName value="Char"/>
                <ArktsMethodName value="getHighSurrogate"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Character" javaMethodName="lowSurrogate" javaMethodArgs="int">
                <!--
                    static char Character.lowSurrogate(int codePoint)
                    ==>
                    static Char.getLowSurrogate(codePoint: int): char
                -->
                <ArktsTypeName value="Char"/>
                <ArktsMethodName value="getLowSurrogate"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Character" javaMethodName="isDigit" javaMethodArgs="char">
                <!--
                    static boolean Character.isDigit(char ch)
                    ==>
                    static Char.isDecDigit(ch: char): boolean
                -->
                <ArktsTypeName value="Char"/>
                <ArktsMethodName value="isDecDigit"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Character" javaMethodName="isHighSurrogate" javaMethodArgs="char">
                <!--
                    static boolean Character.isHighSurrogate(char ch)
                    ==>
                    static Char.isHighSurrogate(ch: char): boolean
                -->
                <ArktsTypeName value="Char"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Character" javaMethodName="isLetter" javaMethodArgs="char">
                <!--
                    static boolean Character.isLetter(char ch)
                    ==>
                    static Char.isLetter(ch: char): boolean
                -->
                <ArktsTypeName value="Char"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Character" javaMethodName="isLowerCase" javaMethodArgs="char">
                <!--
                    static boolean Character.isLowerCase(char ch)
                    ==>
                    static Char.isLowerCase(ch: char): boolean
                -->
                <ArktsTypeName value="Char"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Character" javaMethodName="isLowSurrogate" javaMethodArgs="char">
                <!--
                    static boolean Character.isLowSurrogate(char ch)
                    ==>
                    static Char.isLowSurrogate(ch: char): boolean
                -->
                <ArktsTypeName value="Char"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Character" javaMethodName="isUpperCase" javaMethodArgs="char">
                <!--
                    static boolean Character.isUpperCase(char ch)
                    ==>
                    static Char.isUpperCase(ch: char): boolean
                -->
                <ArktsTypeName value="Char"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Character" javaMethodName="isWhitespace" javaMethodArgs="char">
                <!--
                    static boolean Character.isWhitespace(char ch)
                    ==>
                    static Char.isWhitespace(ch: char): boolean
                -->
                <ArktsTypeName value="Char"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Character" javaMethodName="toLowerCase" javaMethodArgs="char">
                <!--
                    static char Character.toLowerCase(char ch)
                    ==>
                    static Char.toLowerCase(ch: char): char
                -->
                <ArktsTypeName value="Char"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Character" javaMethodName="toString" javaMethodArgs="char">
                <!--
                    static String toString(char c)
                    ==>
                    new Char(c).toString()
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Char(b) -->
                        <TypeReference arktsTypeName="Char"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>

                <Arguments/> <!-- Denotes an empty list of arguments. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Character" javaMethodName="toUpperCase" javaMethodArgs="char">
                <!--
                    static char Character.toUpperCase(char ch)
                    ==>
                    static Char.toUpperCase(ch: char): char
                -->
                <ArktsTypeName value="Char"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Character" javaMethodName="valueOf" javaMethodArgs="char">
                <!--
                    static Character Character.valueOf(char ch)
                    ==>
                    static Char.valueOf(ch: char): Char
                -->
                <ArktsTypeName value="Char"/>
            </CallExpressionRule>
        </CallRules.java.lang.Character>

        <CallRules.java.lang.Double>
            <CallExpressionRule javaType="java.lang.Double" javaMethodName="compare" javaMethodArgs="double,double">
                <!--
                    static int compare(double d1, double d2)
                    ==>
                    new Double(d1).compareTo(new Dobule(d2))
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Double(d1) -->
                        <TypeReference arktsTypeName="Double"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>

                <ArktsMethodName value="compareTo"/>
                <Arguments>
                    <NewClassInstanceExpression> <!-- new Double(d2) -->
                        <TypeReference arktsTypeName="Double"/>
                        <Arguments>
                            <SrcArgument index="1"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </Arguments>
            </CallExpressionRule>
        </CallRules.java.lang.Double>

        <CallRules.java.lang.Float>
          <CallExpressionRule javaType="java.lang.Float" javaMethodName="toString" javaMethodArgs="float">
                  <!--
                  static int toString(float f)
                  ==>
                  new Float(f).toString()
              -->
              <ArktsObject>
                  <NewClassInstanceExpression> <!-- new Float(f) -->
                      <TypeReference arktsTypeName="Float"/>
                      <Arguments>
                          <SrcArgument index="0"/>
                      </Arguments>
                  </NewClassInstanceExpression>
              </ArktsObject>
              <Arguments/> <!-- Denotes an empty list of arguments. -->
          </CallExpressionRule>

          <CallExpressionRule javaType="java.lang.Float" javaMethodName="hashCode" javaMethodArgs="float">
                  <!--
                  static int hashCode(float f)
                  ==>
                  new Float(f).hashCode()
              -->
              <ArktsObject>
                  <NewClassInstanceExpression> <!-- new Float(f) -->
                      <TypeReference arktsTypeName="Float"/>
                      <Arguments>
                          <SrcArgument index="0"/>
                      </Arguments>
                  </NewClassInstanceExpression>
              </ArktsObject>
              <Arguments/> <!-- Denotes an empty list of arguments. -->
          </CallExpressionRule>

          <CallExpressionRule javaType="java.lang.Float" javaMethodName="compare" javaMethodArgs="float,float">
              <!--
                  static int compare(float f1, float f2)
                  ==>
                  new Float(f1).compareTo(new Float(f2))
              -->
              <ArktsObject>
                  <NewClassInstanceExpression> <!-- new Float(f1) -->
                      <TypeReference arktsTypeName="Float"/>
                      <Arguments>
                          <SrcArgument index="0"/>
                      </Arguments>
                  </NewClassInstanceExpression>
              </ArktsObject>

              <ArktsMethodName value="compareTo"/>
              <Arguments>
                  <NewClassInstanceExpression> <!-- new Float(f2) -->
                      <TypeReference arktsTypeName="Float"/>
                      <Arguments>
                          <SrcArgument index="1"/>
                      </Arguments>
                  </NewClassInstanceExpression>
              </Arguments>
          </CallExpressionRule>
        </CallRules.java.lang.Float>

        <CallRules.java.lang.Integer>
            <CallExpressionRule javaType="java.lang.Integer" javaMethodName="compare" javaMethodArgs="int,int">
                <!--
                    static int compare(int i1, int i2)
                    ==>
                    new Int(i1).compareTo(new Int(i2))
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Int(i1) -->
                        <TypeReference arktsTypeName="Int"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>

                <ArktsMethodName value="compareTo"/>
                <Arguments>
                    <NewClassInstanceExpression> <!-- new Int(i2) -->
                        <TypeReference arktsTypeName="Int"/>
                        <Arguments>
                            <SrcArgument index="1"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </Arguments>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Integer" javaMethodName="toString" javaMethodArgs="int">
                <!--
                    static int toString(int i1)
                    ==>
                    new Int(i1).toString()
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Int(i1) -->
                        <TypeReference arktsTypeName="Int"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>

                <Arguments/> <!-- Denotes an empty list of arguments. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Integer" javaMethodName="hashCode" javaMethodArgs="int">
                <!--
                    static int hashCode(int i1)
                    ==>
                    new Int(i1).hashCode()
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Int(i1) -->
                        <TypeReference arktsTypeName="Int"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>
                <Arguments/>
            </CallExpressionRule>
        </CallRules.java.lang.Integer>

        <CallRules.java.lang.Long>
            <CallExpressionRule javaType="java.lang.Long" javaMethodName="compare" javaMethodArgs="long,long">
                <!--
                    static int compare(long l1, long l2)
                    ==>
                    new Long(l1).compareTo(new Long(l2))
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Long(l1) -->
                        <TypeReference arktsTypeName="Long"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>

                <ArktsMethodName value="compareTo"/>
                <Arguments>
                    <NewClassInstanceExpression> <!-- new Long(l2) -->
                        <TypeReference arktsTypeName="Long"/>
                        <Arguments>
                            <SrcArgument index="1"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </Arguments>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Long" javaMethodName="hashCode" javaMethodArgs="long">
                <!--
                    static int hashCode(long i1)
                    ==>
                    new Long(i1).hashCode()
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Long(i1) -->
                        <TypeReference arktsTypeName="Long"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>
                <Arguments/> <!-- Denotes an empty list of arguments. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Long" javaMethodName="toString" javaMethodArgs="long">
                <!--
                    static int toString(long i1)
                    ==>
                    new Long(i1).toString()
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Long(i1) -->
                        <TypeReference arktsTypeName="Long"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>

                <!--        <ArktsMethodName value="toString"/>-->
                <Arguments/> <!-- Denotes an empty list of arguments. -->
            </CallExpressionRule>
        </CallRules.java.lang.Long>

        <CallRules.java.lang.Short>
            <CallExpressionRule javaType="java.lang.Short" javaMethodName="compare" javaMethodArgs="short,short">
                <!--
                    static int compare(short s1, short s2)
                    ==>
                    new Short(s1).compareTo(new Short(s2))
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Short(s1) -->
                        <TypeReference arktsTypeName="Short"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>

                <ArktsMethodName value="compareTo"/>
                <Arguments>
                    <NewClassInstanceExpression> <!-- new Short(s2) -->
                        <TypeReference arktsTypeName="Short"/>
                        <Arguments>
                            <SrcArgument index="1"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </Arguments>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Short" javaMethodName="toString" javaMethodArgs="short">
                <!--
                    static int toString(short s)
                    ==>
                    new Short(s).toString()
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Short(s) -->
                        <TypeReference arktsTypeName="Short"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>
                <Arguments/> <!-- Denotes an empty list of arguments. -->
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.Short" javaMethodName="hashCode" javaMethodArgs="short">
                <!--
                    static int hashCode(short s)
                    ==>
                    new Short(s).hashCode()
                -->
                <ArktsObject>
                    <NewClassInstanceExpression> <!-- new Short(s) -->
                        <TypeReference arktsTypeName="Short"/>
                        <Arguments>
                            <SrcArgument index="0"/>
                        </Arguments>
                    </NewClassInstanceExpression>
                </ArktsObject>
                <Arguments/> <!-- Denotes an empty list of arguments. -->
            </CallExpressionRule>
        </CallRules.java.lang.Short>

        <CallRules.java.lang.String>
            <CallExpressionRule javaType="java.lang.String" javaMethodName="contains" javaMethodArgs="java.lang.CharSequence">
                <!--
                    boolean contains(CharSequence s)
                    ==>
                    contains(s: String, fromIndex=0: int): boolean
                -->

                <!-- <ArktsMethodName value="contains"/> -->
                <Arguments>
                    <SrcArgument index="0"/>
                    <Literal type="decimal" value="0"/>
                </Arguments>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.String" javaMethodName="join" javaMethodArgs="java.lang.CharSequence,java.lang.CharSequence[]">
                <!--
                    static String join(CharSequence delimiter, CharSequence... elements)
                    ==>
                    public join(strings: String[], delim: String): String
                -->
                <Arguments> <!--; Just reorder arguments. -->
                    <SrcArgumentsTail index="1"/>  All source arguments starting from the second one should be combined into the array which will be the very first argument on output.
                    <SrcArgument index="0"/>
                </Arguments>
            </CallExpressionRule>

<!--         The next rule is commented out as at the moment there is no way to convert Iterable<? extencs String> into an array of strings. -->
<!--            <CallExpressionRule javaType="java.lang.String" javaMethodName="join" javaMethodArgs="java.lang.CharSequence,java.lang.Iterable<? extends java.lang.CharSequence>">-->
<!--                &lt;!&ndash;-->
<!--                    join(CharSequence delimiter, Iterable<? extends CharSequence> elements)-->
<!--                    ==>-->
<!--                    public join(strings: String[], delim: String): String-->
<!--                &ndash;&gt;-->
<!--                <Arguments> &lt;!&ndash; Just reorder arguments. &ndash;&gt;-->
<!--                    <SrcArgumentsTail index="1"/>  All source arguments starting from the second one should be combined into the array which will be the very first argument on output. -->
<!--                    <SrcArgument index="0"/>-->
<!--                </Arguments>-->
<!--            </CallExpressionRule>-->

            <CallExpressionRule javaType="java.lang.String" javaMethodName="valueOf" javaMethodArgs="char">
                <!--
                    static String String.valueOf(char c)
                    ==>
                    static StringBuilder.toString(c: char): String
                -->
                <ArktsTypeName value="StringBuilder"/>
                <ArktsMethodName value="toString"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.String" javaMethodName="valueOf" javaMethodArgs="double">
                <!--
                    static String String.valueOf(double d)
                    ==>
                    static StringBuilder.toString(d: double): String
                -->
                <ArktsTypeName value="StringBuilder"/>
                <ArktsMethodName value="toString"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.String" javaMethodName="valueOf" javaMethodArgs="float">
                <!--
                    static String String.valueOf(float f)
                    ==>
                    static StringBuilder.toString(f: float): String
                -->
                <ArktsTypeName value="StringBuilder"/>
                <ArktsMethodName value="toString"/>
                <!-- <Arguments> element is needed only to doe the type cast. And it needed as the convertor flat literals
                converts to double (as ArkTS doesn't have any prefix for float literal types). -->
                <Arguments>
                    <CastExpression index="0"> <!-- The original argument index to be cast. -->
                        <PrimaryType> <!-- The type to which to do the cast. -->
                            <PredefinedType name="float"/>
                        </PrimaryType>
                    </CastExpression>
                </Arguments>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.String" javaMethodName="valueOf" javaMethodArgs="int">
                <!--
                    static String String.valueOf(int i)
                    ==>
                    static StringBuilder.toString(i: int): String
                -->
                <ArktsTypeName value="StringBuilder"/>
                <ArktsMethodName value="toString"/>
            </CallExpressionRule>

            <CallExpressionRule javaType="java.lang.String" javaMethodName="valueOf" javaMethodArgs="long">
                <!--
                    static String String.valueOf(long l)
                    ==>
                    static StringBuilder.toString(l: long): String
                -->
                <ArktsTypeName value="StringBuilder"/>
                <ArktsMethodName value="toString"/>
                <!-- <Arguments> element is needed only to do the type cast. And it needed as the convertor long literals
                converts to int (as ArkTS doesn't have any prefix for long literal types). -->
                <Arguments>
                    <CastExpression index="0"> <!-- The original argument index to be cast. -->
                        <PrimaryType> <!-- The type to which to do the cast. -->
                            <PredefinedType name="long"/>
                        </PrimaryType>
                    </CastExpression>
                </Arguments>
            </CallExpressionRule>
        </CallRules.java.lang.String>
    </CallRules>

    <TypeReferenceRules>
        <TypeReferenceRule javaType="java.lang.Integer">
            <TypeReference arktsTypeName="Int"/>
        </TypeReferenceRule>

        <TypeReferenceRule javaType="java.lang.Character">
            <TypeReference arktsTypeName="Char"/>
        </TypeReferenceRule>

        <TypeReferenceRule javaType="java.lang.Number">
            <TypeReference arktsTypeName="Integral"/>
        </TypeReferenceRule>
    </TypeReferenceRules>

    <MemberAccessRules>
        <!-- The next rule assumes 'import * from "std/math/math"' or 'import e from "std/math/math"' is added to the code. -->
        <MemberAccessExpressionRule javaType="java.lang.Math" javaMemberName="E" arktsName="e"/>
        <MemberAccessExpressionRule javaType="java.lang.Byte" javaMemberName="BYTES" arktsName="BYTE_SIZE"/>
        <MemberAccessExpressionRule javaType="java.lang.Byte" javaMemberName="SIZE" arktsName="BIT_SIZE"/>
        <MemberAccessExpressionRule javaType="java.lang.Character" javaMemberName="SIZE" arktsName="CHAR_BIT_SIZE">
            <TypeReference arktsTypeName="Char"/>
        </MemberAccessExpressionRule>
        <MemberAccessExpressionRule javaType="java.lang.Character" javaMemberName="MIN_HIGH_SURROGATE" arktsName="HIGH_SURROGATE_MIN">
            <TypeReference arktsTypeName="Char"/>
        </MemberAccessExpressionRule>
        <MemberAccessExpressionRule javaType="java.lang.Character" javaMemberName="MIN_LOW_SURROGATE" arktsName="LOW_SURROGATE_MIN">
            <TypeReference arktsTypeName="Char"/>
        </MemberAccessExpressionRule>
        <MemberAccessExpressionRule javaType="java.lang.Character" javaMemberName="MAX_HIGH_SURROGATE" arktsName="HIGH_SURROGATE_MAX">
            <TypeReference arktsTypeName="Char"/>
        </MemberAccessExpressionRule>
        <MemberAccessExpressionRule javaType="java.lang.Character" javaMemberName="MAX_LOW_SURROGATE" arktsName="LOW_SURROGATE_MAX">
            <TypeReference arktsTypeName="Char"/>
        </MemberAccessExpressionRule>
        <MemberAccessExpressionRule javaType="java.lang.Double" javaMemberName="BYTES" arktsName="BYTE_SIZE"/>
        <MemberAccessExpressionRule javaType="java.lang.Double" javaMemberName="SIZE" arktsName="BIT_SIZE"/>
        <MemberAccessExpressionRule javaType="java.lang.Float" javaMemberName="BYTES" arktsName="BYTE_SIZE"/>
        <MemberAccessExpressionRule javaType="java.lang.Float" javaMemberName="SIZE" arktsName="BIT_SIZE"/>
        <MemberAccessExpressionRule javaType="java.lang.Integer" javaMemberName="BYTES" arktsName="BYTE_SIZE">
            <TypeReference arktsTypeName="Int"/>
        </MemberAccessExpressionRule>
        <MemberAccessExpressionRule javaType="java.lang.Integer" javaMemberName="SIZE" arktsName="BIT_SIZE">
            <TypeReference arktsTypeName="Int"/>
        </MemberAccessExpressionRule>
        <MemberAccessExpressionRule javaType="java.lang.Long" javaMemberName="BYTES" arktsName="BYTE_SIZE"/>
        <MemberAccessExpressionRule javaType="java.lang.Long" javaMemberName="SIZE" arktsName="BIT_SIZE"/>
        <MemberAccessExpressionRule javaType="java.lang.Short" javaMemberName="BYTES" arktsName="BYTE_SIZE"/>
        <MemberAccessExpressionRule javaType="java.lang.Short" javaMemberName="SIZE" arktsName="BIT_SIZE"/>
        <MemberAccessExpressionRule javaType="java.lang.String" javaMemberName="length">
            <CallExpression arktsMethodName="length">
                <!-- int length() -->
                <Arguments/> <!-- Denotes an empty list of arguments. -->
            </CallExpression>
        </MemberAccessExpressionRule>
    </MemberAccessRules>

    <NewClassInstanceExpressionRules>
        <NewClassInstanceExpressionRule javaType="java.lang.Character" javaMethodArgs="char">
            <TypeReference arktsTypeName="Char"/>
        </NewClassInstanceExpressionRule>

        <NewClassInstanceExpressionRule javaType="java.lang.Number">
            <TypeReference arktsTypeName="Integral"/>
        </NewClassInstanceExpressionRule>
    </NewClassInstanceExpressionRules>
</JavaApiMappingRules>
